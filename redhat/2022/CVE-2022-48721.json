{
  "affected_release": null,
  "package_state": [
    {
      "product_name": "Red Hat Enterprise Linux 6",
      "fix_state": "Not affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:6"
    },
    {
      "product_name": "Red Hat Enterprise Linux 7",
      "fix_state": "Not affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:7"
    },
    {
      "product_name": "Red Hat Enterprise Linux 7",
      "fix_state": "Not affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:7"
    },
    {
      "product_name": "Red Hat Enterprise Linux 8",
      "fix_state": "Affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:8"
    },
    {
      "product_name": "Red Hat Enterprise Linux 8",
      "fix_state": "Affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:8"
    },
    {
      "product_name": "Red Hat Enterprise Linux 9",
      "fix_state": "Affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:9"
    },
    {
      "product_name": "Red Hat Enterprise Linux 9",
      "fix_state": "Affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:9"
    }
  ],
  "threat_severity": "Moderate",
  "public_date": "2024-06-20T00:00:00Z",
  "bugzilla": {
    "description": "kernel: net/smc: Forward wakeup to smc socket waitqueue after fallback",
    "id": "2293281",
    "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2293281"
  },
  "cvss": {
    "cvss_base_score": "",
    "cvss_scoring_vector": "",
    "status": ""
  },
  "cvss3": {
    "cvss3_base_score": "5.5",
    "cvss3_scoring_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "status": "draft"
  },
  "iava": "",
  "cwe": "CWE-99",
  "statement": "",
  "acknowledgement": "",
  "name": "CVE-2022-48721",
  "document_distribution": "",
  "details": [
    "In the Linux kernel, the following vulnerability has been resolved:\nnet/smc: Forward wakeup to smc socket waitqueue after fallback\nWhen we replace TCP with SMC and a fallback occurs, there may be\nsome socket waitqueue entries remaining in smc socket-\u003ewq, such\nas eppoll_entries inserted by userspace applications.\nAfter the fallback, data flows over TCP/IP and only clcsocket-\u003ewq\nwill be woken up. Applications can't be notified by the entries\nwhich were inserted in smc socket-\u003ewq before fallback. So we need\na mechanism to wake up smc socket-\u003ewq at the same time if some\nentries remaining in it.\nThe current workaround is to transfer the entries from smc socket-\u003ewq\nto clcsock-\u003ewq during the fallback. But this may cause a crash\nlike this:\ngeneral protection fault, probably for non-canonical address 0xdead000000000100: 0000 [#1] PREEMPT SMP PTI\nCPU: 3 PID: 0 Comm: swapper/3 Kdump: loaded Tainted: G E     5.16.0+ #107\nRIP: 0010:__wake_up_common+0x65/0x170\nCall Trace:\n\u003cIRQ\u003e\n__wake_up_common_lock+0x7a/0xc0\nsock_def_readable+0x3c/0x70\ntcp_data_queue+0x4a7/0xc40\ntcp_rcv_established+0x32f/0x660\n? sk_filter_trim_cap+0xcb/0x2e0\ntcp_v4_do_rcv+0x10b/0x260\ntcp_v4_rcv+0xd2a/0xde0\nip_protocol_deliver_rcu+0x3b/0x1d0\nip_local_deliver_finish+0x54/0x60\nip_local_deliver+0x6a/0x110\n? tcp_v4_early_demux+0xa2/0x140\n? tcp_v4_early_demux+0x10d/0x140\nip_sublist_rcv_finish+0x49/0x60\nip_sublist_rcv+0x19d/0x230\nip_list_rcv+0x13e/0x170\n__netif_receive_skb_list_core+0x1c2/0x240\nnetif_receive_skb_list_internal+0x1e6/0x320\nnapi_complete_done+0x11d/0x190\nmlx5e_napi_poll+0x163/0x6b0 [mlx5_core]\n__napi_poll+0x3c/0x1b0\nnet_rx_action+0x27c/0x300\n__do_softirq+0x114/0x2d2\nirq_exit_rcu+0xb4/0xe0\ncommon_interrupt+0xba/0xe0\n\u003c/IRQ\u003e\n\u003cTASK\u003e\nThe crash is caused by privately transferring waitqueue entries from\nsmc socket-\u003ewq to clcsock-\u003ewq. The owners of these entries, such as\nepoll, have no idea that the entries have been transferred to a\ndifferent socket wait queue and still use original waitqueue spinlock\n(smc socket-\u003ewq.wait.lock) to make the entries operation exclusive,\nbut it doesn't work. The operations to the entries, such as removing\nfrom the waitqueue (now is clcsock-\u003ewq after fallback), may cause a\ncrash when clcsock waitqueue is being iterated over at the moment.\nThis patch tries to fix this by no longer transferring wait queue\nentries privately, but introducing own implementations of clcsock's\ncallback functions in fallback situation. The callback functions will\nforward the wakeup to smc socket-\u003ewq if clcsock-\u003ewq is actually woken\nup and smc socket-\u003ewq has remaining entries."
  ],
  "references": [
    "https://www.cve.org/CVERecord?id=CVE-2022-48721\nhttps://nvd.nist.gov/vuln/detail/CVE-2022-48721\nhttps://lore.kernel.org/linux-cve-announce/2024062056-CVE-2022-48721-3959@gregkh/T"
  ]
}