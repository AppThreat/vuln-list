{
  "affected_release": null,
  "package_state": [
    {
      "product_name": "Red Hat Enterprise Linux 6",
      "fix_state": "Out of support scope",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:6"
    },
    {
      "product_name": "Red Hat Enterprise Linux 7",
      "fix_state": "Out of support scope",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:7"
    },
    {
      "product_name": "Red Hat Enterprise Linux 7",
      "fix_state": "Out of support scope",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:7"
    },
    {
      "product_name": "Red Hat Enterprise Linux 8",
      "fix_state": "Not affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:8"
    },
    {
      "product_name": "Red Hat Enterprise Linux 8",
      "fix_state": "Not affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:8"
    },
    {
      "product_name": "Red Hat Enterprise Linux 9",
      "fix_state": "Not affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:9"
    },
    {
      "product_name": "Red Hat Enterprise Linux 9",
      "fix_state": "Not affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:9"
    }
  ],
  "threat_severity": "Moderate",
  "public_date": "2024-05-01T00:00:00Z",
  "bugzilla": {
    "description": "kernel: btrfs: fix race when detecting delalloc ranges during fiemap",
    "id": "2278490",
    "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2278490"
  },
  "cvss": {
    "cvss_base_score": "",
    "cvss_scoring_vector": "",
    "status": ""
  },
  "cvss3": {
    "cvss3_base_score": "5.5",
    "cvss3_scoring_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "status": "draft"
  },
  "iava": "",
  "cwe": "",
  "statement": "",
  "acknowledgement": "",
  "name": "CVE-2024-27080",
  "document_distribution": "",
  "details": [
    "In the Linux kernel, the following vulnerability has been resolved:\nbtrfs: fix race when detecting delalloc ranges during fiemap\nFor fiemap we recently stopped locking the target extent range for the\nwhole duration of the fiemap call, in order to avoid a deadlock in a\nscenario where the fiemap buffer happens to be a memory mapped range of\nthe same file. This use case is very unlikely to be useful in practice but\nit may be triggered by fuzz testing (syzbot, etc).\nThis however introduced a race that makes us miss delalloc ranges for\nfile regions that are currently holes, so the caller of fiemap will not\nbe aware that there's data for some file regions. This can be quite\nserious for some use cases - for example in coreutils versions before 9.0,\nthe cp program used fiemap to detect holes and data in the source file,\ncopying only regions with data (extents or delalloc) from the source file\nto the destination file in order to preserve holes (see the documentation\nfor its --sparse command line option). This means that if cp was used\nwith a source file that had delalloc in a hole, the destination file could\nend up without that data, which is effectively a data loss issue, if it\nhappened to hit the race described below.\nThe race happens like this:\n1) Fiemap is called, without the FIEMAP_FLAG_SYNC flag, for a file that\nhas delalloc in the file range [64M, 65M[, which is currently a hole;\n2) Fiemap locks the inode in shared mode, then starts iterating the\ninode's subvolume tree searching for file extent items, without having\nthe whole fiemap target range locked in the inode's io tree - the\nchange introduced recently by commit b0ad381fa769 (\"btrfs: fix\ndeadlock with fiemap and extent locking\"). It only locks ranges in\nthe io tree when it finds a hole or prealloc extent since that\ncommit;\n3) Note that fiemap clones each leaf before using it, and this is to\navoid deadlocks when locking a file range in the inode's io tree and\nthe fiemap buffer is memory mapped to some file, because writing\nto the page with btrfs_page_mkwrite() will wait on any ordered extent\nfor the page's range and the ordered extent needs to lock the range\nand may need to modify the same leaf, therefore leading to a deadlock\non the leaf;\n4) While iterating the file extent items in the cloned leaf before\nfinding the hole in the range [64M, 65M[, the delalloc in that range\nis flushed and its ordered extent completes - meaning the corresponding\nfile extent item is in the inode's subvolume tree, but not present in\nthe cloned leaf that fiemap is iterating over;\n5) When fiemap finds the hole in the [64M, 65M[ range by seeing the gap in\nthe cloned leaf (or a file extent item with disk_bytenr == 0 in case\nthe NO_HOLES feature is not enabled), it will lock that file range in\nthe inode's io tree and then search for delalloc by checking for the\nEXTENT_DELALLOC bit in the io tree for that range and ordered extents\n(with btrfs_find_delalloc_in_range()). But it finds nothing since the\ndelalloc in that range was already flushed and the ordered extent\ncompleted and is gone - as a result fiemap will not report that there's\ndelalloc or an extent for the range [64M, 65M[, so user space will be\nmislead into thinking that there's a hole in that range.\nThis could actually be sporadically triggered with test case generic/094\nfrom fstests, which reports a missing extent/delalloc range like this:\ngeneric/094 2s ... - output mismatch (see /home/fdmanana/git/hub/xfstests/results//generic/094.out.bad)\n--- tests/generic/094.out2020-06-10 19:29:03.830519425 +0100\n+++ /home/fdmanana/git/hub/xfstests/results//generic/094.out.bad2024-02-28 11:00:00.381071525 +0000\n@@ -1,3 +1,9 @@\nQA output created by 094\nfiemap run with sync\nfiemap run without sync\n+ERROR: couldn't find extent at 7\n+map is 'HHDDHPPDPHPH'\n+logical: [       5..       6] phys:\n---truncated---"
  ],
  "references": [
    "https://www.cve.org/CVERecord?id=CVE-2024-27080\nhttps://nvd.nist.gov/vuln/detail/CVE-2024-27080\nhttps://lore.kernel.org/linux-cve-announce/2024050135-CVE-2024-27080-46f0@gregkh/T"
  ]
}