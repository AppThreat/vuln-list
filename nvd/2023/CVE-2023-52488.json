{
  "id": "CVE-2023-52488",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-03-11T18:15:16.603",
  "lastModified": "2024-04-10T15:16:03.963",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nserial: sc16is7xx: convert from _raw_ to _noinc_ regmap functions for FIFO\n\nThe SC16IS7XX IC supports a burst mode to access the FIFOs where the\ninitial register address is sent ($00), followed by all the FIFO data\nwithout having to resend the register address each time. In this mode, the\nIC doesn't increment the register address for each R/W byte.\n\nThe regmap_raw_read() and regmap_raw_write() are functions which can\nperform IO over multiple registers. They are currently used to read/write\nfrom/to the FIFO, and although they operate correctly in this burst mode on\nthe SPI bus, they would corrupt the regmap cache if it was not disabled\nmanually. The reason is that when the R/W size is more than 1 byte, these\nfunctions assume that the register address is incremented and handle the\ncache accordingly.\n\nConvert FIFO R/W functions to use the regmap _noinc_ versions in order to\nremove the manual cache control which was a workaround when using the\n_raw_ versions. FIFO registers are properly declared as volatile so\ncache will not be used/updated for FIFO accesses."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: serial: sc16is7xx: convierte de _raw_ a _noinc_ funciones regmap para FIFO El IC SC16IS7XX admite un modo de ráfaga para acceder a los FIFO donde se envía la dirección de registro inicial ($00), seguida de todas los datos FIFO sin tener que reenviar la dirección de registro cada vez. En este modo, el IC no incrementa la dirección de registro para cada byte de lectura/escritura. regmap_raw_read() y regmap_raw_write() son funciones que pueden realizar IO en múltiples registros. Actualmente se utilizan para leer/escribir desde/hacia FIFO y, aunque funcionan correctamente en este modo de ráfaga en el bus SPI, dañarían el caché de regmap si no se desactivara manualmente. La razón es que cuando el tamaño de lectura y escritura es superior a 1 byte, estas funciones asumen que la dirección del registro se incrementa y manejan la caché en consecuencia. Convierta las funciones FIFO R/W para usar las versiones regmap _noinc_ para eliminar el control de caché manual, que era una solución alternativa al usar las versiones _raw_. Los registros FIFO se declaran correctamente como volátiles, por lo que la caché no se utilizará ni se actualizará para los accesos FIFO."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/084c24e788d9cf29c55564de368bf5284f2bb5db",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/416b10d2817c94db86829fb92ad43ce7d002c573",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/aa7cb4787698add9367b19f7afc667662c9bdb23",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/dbf4ab821804df071c8b566d9813083125e6d97b",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/e635f652696ef6f1230621cfd89c350cb5ec6169",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}