{
  "id": "CVE-2022-48733",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-06-20T12:15:11.700",
  "lastModified": "2024-06-20T12:43:25.663",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix use-after-free after failure to create a snapshot\n\nAt ioctl.c:create_snapshot(), we allocate a pending snapshot structure and\nthen attach it to the transaction's list of pending snapshots. After that\nwe call btrfs_commit_transaction(), and if that returns an error we jump\nto 'fail' label, where we kfree() the pending snapshot structure. This can\nresult in a later use-after-free of the pending snapshot:\n\n1) We allocated the pending snapshot and added it to the transaction's\n   list of pending snapshots;\n\n2) We call btrfs_commit_transaction(), and it fails either at the first\n   call to btrfs_run_delayed_refs() or btrfs_start_dirty_block_groups().\n   In both cases, we don't abort the transaction and we release our\n   transaction handle. We jump to the 'fail' label and free the pending\n   snapshot structure. We return with the pending snapshot still in the\n   transaction's list;\n\n3) Another task commits the transaction. This time there's no error at\n   all, and then during the transaction commit it accesses a pointer\n   to the pending snapshot structure that the snapshot creation task\n   has already freed, resulting in a user-after-free.\n\nThis issue could actually be detected by smatch, which produced the\nfollowing warning:\n\n  fs/btrfs/ioctl.c:843 create_snapshot() warn: '\u0026pending_snapshot-\u003elist' not removed from list\n\nSo fix this by not having the snapshot creation ioctl directly add the\npending snapshot to the transaction's list. Instead add the pending\nsnapshot to the transaction handle, and then at btrfs_commit_transaction()\nwe add the snapshot to the list only when we can guarantee that any error\nreturned after that point will result in a transaction abort, in which\ncase the ioctl code can safely free the pending snapshot and no one can\naccess it anymore."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se resolvió la siguiente vulnerabilidad: btrfs: corrige el use-after-free después de una falla al crear una instantánea En ioctl.c:create_snapshot(), asignamos una estructura de instantánea pendiente y luego la adjuntamos a la lista de transacciones de instantáneas pendientes. Después de eso, llamamos a btrfs_commit_transaction(), y si eso devuelve un error, saltamos a la etiqueta 'falla', donde liberamos() la estructura de instantánea pendiente. Esto puede resultar en un uso posterior después de la liberación de la instantánea pendiente: 1) Asignamos la instantánea pendiente y la agregamos a la lista de instantáneas pendientes de la transacción; 2) Llamamos a btrfs_commit_transaction(), y falla en la primera llamada a btrfs_run_delayed_refs() o btrfs_start_dirty_block_groups(). En ambos casos, no abortamos la transacción y liberamos nuestro identificador de transacción. Saltamos a la etiqueta 'fallo' y liberamos la estructura de instantánea pendiente. Regresamos con la instantánea pendiente todavía en la lista de transacciones; 3) Otra tarea confirma la transacción. Esta vez no hay ningún error y luego, durante la confirmación de la transacción, accede a un puntero a la estructura de instantánea pendiente que la tarea de creación de instantánea ya ha liberado, lo que resulta en una liberación de usuario. En realidad, este problema podría ser detectado por smatch, que produjo la siguiente advertencia: fs/btrfs/ioctl.c:843 create_snapshot() advertencia: '\u0026amp;pending_snapshot-\u0026gt;list' no se elimina de la lista. Así que solucione este problema al no tener el ioctl de creación de instantáneas directamente agregue la instantánea pendiente a la lista de transacciones. En su lugar, agregue la instantánea pendiente al identificador de la transacción, y luego en btrfs_commit_transaction() agregamos la instantánea a la lista solo cuando podamos garantizar que cualquier error devuelto después de ese punto resultará en la cancelación de la transacción, en cuyo caso el código ioctl puede Libera la instantánea pendiente y ya nadie podrá acceder a ella."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/28b21c558a3753171097193b6f6602a94169093a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/9372fa1d73da5f1673921e365d0cd2c27ec7adc2",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/a7b717fa15165d3d9245614680bebc48a52ac05d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}