{
  "id": "CVE-2024-26740",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-04-03T17:15:51.410",
  "lastModified": "2024-04-03T17:24:18.150",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: act_mirred: use the backlog for mirred ingress\n\nThe test Davide added in commit ca22da2fbd69 (\"act_mirred: use the backlog\nfor nested calls to mirred ingress\") hangs our testing VMs every 10 or so\nruns, with the familiar tcp_v4_rcv -\u003e tcp_v4_rcv deadlock reported by\nlockdep.\n\nThe problem as previously described by Davide (see Link) is that\nif we reverse flow of traffic with the redirect (egress -\u003e ingress)\nwe may reach the same socket which generated the packet. And we may\nstill be holding its socket lock. The common solution to such deadlocks\nis to put the packet in the Rx backlog, rather than run the Rx path\ninline. Do that for all egress -\u003e ingress reversals, not just once\nwe started to nest mirred calls.\n\nIn the past there was a concern that the backlog indirection will\nlead to loss of error reporting / less accurate stats. But the current\nworkaround does not seem to address the issue."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se resolvió la siguiente vulnerabilidad: net/sched: act_mirred: use el trabajo pendiente para el ingreso duplicado. La prueba que Davide agregó en el compromiso ca22da2fbd69 (\"act_mirred: use el trabajo pendiente para llamadas anidadas para el ingreso duplicado\") bloquea nuestras máquinas virtuales de prueba. aproximadamente cada 10 ejecuciones, con el conocido punto muerto tcp_v4_rcv -\u0026gt; tcp_v4_rcv informado por lockdep. El problema descrito anteriormente por Davide (ver Enlace) es que si invertimos el flujo de tráfico con la redirección (salida -\u0026gt; entrada) podemos llegar al mismo socket que generó el paquete. Y es posible que todavía estemos sosteniendo el bloqueo del enchufe. La solución común a estos puntos muertos es colocar el paquete en el trabajo pendiente de Rx, en lugar de ejecutar la ruta de Rx en línea. Haga eso para todas las reversiones de salida -\u0026gt; entrada, no solo una vez que comenzamos a anidar llamadas reflejadas. En el pasado, existía la preocupación de que la dirección indirecta del trabajo pendiente provocara la pérdida de informes de errores o estadísticas menos precisas. Pero la solución actual no parece solucionar el problema."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/52f671db18823089a02f07efc04efdb2272ddc17",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/60ddea1600bc476e0f5e02bce0e29a460ccbf0be",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/7c787888d164689da8b1b115f3ef562c1e843af4",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}