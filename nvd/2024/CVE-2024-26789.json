{
  "id": "CVE-2024-26789",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-04-04T09:15:08.400",
  "lastModified": "2024-04-04T12:48:41.700",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: arm64/neonbs - fix out-of-bounds access on short input\n\nThe bit-sliced implementation of AES-CTR operates on blocks of 128\nbytes, and will fall back to the plain NEON version for tail blocks or\ninputs that are shorter than 128 bytes to begin with.\n\nIt will call straight into the plain NEON asm helper, which performs all\nmemory accesses in granules of 16 bytes (the size of a NEON register).\nFor this reason, the associated plain NEON glue code will copy inputs\nshorter than 16 bytes into a temporary buffer, given that this is a rare\noccurrence and it is not worth the effort to work around this in the asm\ncode.\n\nThe fallback from the bit-sliced NEON version fails to take this into\naccount, potentially resulting in out-of-bounds accesses. So clone the\nsame workaround, and use a temp buffer for short in/outputs."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: crypto: arm64/neonbs: corrige el acceso fuera de los límites en entradas cortas. La implementación de bits de AES-CTR opera en bloques de 128 bytes y recurrirá al Versión NEON simple para bloques finales o entradas que, para empezar, tienen menos de 128 bytes. Llamará directamente al asistente simple NEON asm, que realiza todos los accesos a la memoria en gránulos de 16 bytes (el tamaño de un registro NEON). Por esta razón, el código de pegamento NEON simple asociado copiará las entradas de menos de 16 bytes en un búfer temporal, dado que esto es algo poco común y no vale la pena el esfuerzo de solucionarlo en el código ASM. El respaldo de la versión NEON dividida en bits no tiene esto en cuenta, lo que podría provocar accesos fuera de los límites. Así que clone la misma solución y use un búfer temporal para entradas/salidas cortas."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/034e2d70b5c7f578200ad09955aeb2aa65d1164a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/1291d278b5574819a7266568ce4c28bce9438705",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/1c0cf6d19690141002889d72622b90fc01562ce4",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/9e8ecd4908b53941ab6f0f51584ab80c6c6606c4",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}