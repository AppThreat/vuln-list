{
  "id": "CVE-2024-26806",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-04-04T09:15:09.333",
  "lastModified": "2024-04-04T12:48:22.650",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nspi: cadence-qspi: remove system-wide suspend helper calls from runtime PM hooks\n\nThe -\u003eruntime_suspend() and -\u003eruntime_resume() callbacks are not\nexpected to call spi_controller_suspend() and spi_controller_resume().\nRemove calls to those in the cadence-qspi driver.\n\nThose helpers have two roles currently:\n - They stop/start the queue, including dealing with the kworker.\n - They toggle the SPI controller SPI_CONTROLLER_SUSPENDED flag. It\n   requires acquiring ctlr-\u003ebus_lock_mutex.\n\nStep one is irrelevant because cadence-qspi is not queued. Step two\nhowever has two implications:\n - A deadlock occurs, because -\u003eruntime_resume() is called in a context\n   where the lock is already taken (in the -\u003eexec_op() callback, where\n   the usage count is incremented).\n - It would disallow all operations once the device is auto-suspended.\n\nHere is a brief call tree highlighting the mutex deadlock:\n\nspi_mem_exec_op()\n        ...\n        spi_mem_access_start()\n                mutex_lock(\u0026ctlr-\u003ebus_lock_mutex)\n\n        cqspi_exec_mem_op()\n                pm_runtime_resume_and_get()\n                        cqspi_resume()\n                                spi_controller_resume()\n                                        mutex_lock(\u0026ctlr-\u003ebus_lock_mutex)\n                ...\n\n        spi_mem_access_end()\n                mutex_unlock(\u0026ctlr-\u003ebus_lock_mutex)\n        ..."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: spi: cadence-qspi: elimina las llamadas auxiliares de suspensión en todo el sistema desde los ganchos PM en tiempo de ejecución No se espera que las devoluciones de llamada -\u0026gt;runtime_suspend() y -\u0026gt;runtime_resume() llamen a spi_controller_suspend() y spi_controller_resume(). Elimina llamadas a aquellos en el controlador cadence-qspi. Esos ayudantes tienen actualmente dos funciones: - Detienen/inician la cola, incluido el trato con el kworker. - Alternan el indicador SPI_CONTROLLER_SUSPENDED del controlador SPI. Requiere adquirir ctlr-\u0026gt;bus_lock_mutex. El primer paso es irrelevante porque cadence-qspi no está en cola. Sin embargo, el segundo paso tiene dos implicaciones: - Se produce un punto muerto, porque -\u0026gt;runtime_resume() se llama en un contexto donde el bloqueo ya está tomado (en la devolución de llamada -\u0026gt;exec_op(), donde se incrementa el recuento de uso). - No permitiría todas las operaciones una vez que el dispositivo se autosuspenda. Aquí hay un breve árbol de llamadas que resalta el interbloqueo mutex: spi_mem_exec_op() ... spi_mem_access_start() mutex_lock(\u0026amp;ctlr-\u0026gt;bus_lock_mutex) cqspi_exec_mem_op() pm_runtime_resume_and_get() cqspi_resume() spi_controller_resume() mutex_lock(\u0026amp;ctlr-\u0026gt;bus_lock_mutex) ... spi_mem _acceso_end () mutex_unlock(\u0026amp;ctlr-\u0026gt;bus_lock_mutex) ..."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/041562ebc4759c9932b59a06527f8753b86da365",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/959043afe53ae80633e810416cee6076da6e91c6",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}