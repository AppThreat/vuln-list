{
  "id": "CVE-2024-36961",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-06-03T08:15:09.660",
  "lastModified": "2024-06-03T14:46:24.250",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nthermal/debugfs: Fix two locking issues with thermal zone debug\n\nWith the current thermal zone locking arrangement in the debugfs code,\nuser space can open the \"mitigations\" file for a thermal zone before\nthe zone's debugfs pointer is set which will result in a NULL pointer\ndereference in tze_seq_start().\n\nMoreover, thermal_debug_tz_remove() is not called under the thermal\nzone lock, so it can run in parallel with the other functions accessing\nthe thermal zone's struct thermal_debugfs object.  Then, it may clear\ntz-\u003edebugfs after one of those functions has checked it and the\nstruct thermal_debugfs object may be freed prematurely.\n\nTo address the first problem, pass a pointer to the thermal zone's\nstruct thermal_debugfs object to debugfs_create_file() in\nthermal_debug_tz_add() and make tze_seq_start(), tze_seq_next(),\ntze_seq_stop(), and tze_seq_show() retrieve it from s-\u003eprivate\ninstead of a pointer to the thermal zone object.  This will ensure\nthat tz_debugfs will be valid across the \"mitigations\" file accesses\nuntil thermal_debugfs_remove_id() called by thermal_debug_tz_remove()\nremoves that file.\n\nTo address the second problem, use tz-\u003elock in thermal_debug_tz_remove()\naround the tz-\u003edebugfs value check (in case the same thermal zone is\nremoved at the same time in two different threads) and its reset to NULL.\n\nCc :6.8+ \u003cstable@vger.kernel.org\u003e # 6.8+"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: Thermal/debugfs: soluciona dos problemas de bloqueo con la depuración de la zona térmica. Con la disposición actual de bloqueo de la zona térmica en el código debugfs, el espacio de usuario puede abrir el archivo de \"mitigaciones\" para una zona térmica antes. El puntero debugfs de la zona está configurado, lo que dará como resultado una desreferencia del puntero NULL en tze_seq_start(). Además, Thermal_debug_tz_remove() no se llama bajo el bloqueo de la zona térmica, por lo que puede ejecutarse en paralelo con las otras funciones que acceden al objeto struct Thermal_debugfs de la zona térmica. Luego, puede borrar tz-\u0026gt;debugfs después de que una de esas funciones lo haya verificado y el objeto struct Thermal_debugfs puede liberarse prematuramente. Para solucionar el primer problema, pase un puntero al objeto struct Thermal_debugfs de la zona térmica para debugfs_create_file() en Thermal_debug_tz_add() y haga que tze_seq_start(), tze_seq_next(), tze_seq_stop() y tze_seq_show() lo recuperen de s-\u0026gt;private. de un puntero al objeto de la zona térmica. Esto garantizará que tz_debugfs sea válido en todos los accesos a archivos de \"mitigaciones\" hasta que Thermal_debugfs_remove_id() llamado por Thermal_debug_tz_remove() elimine ese archivo. Para solucionar el segundo problema, use tz-\u0026gt;lock en Thermal_debug_tz_remove() alrededor de la verificación del valor de tz-\u0026gt;debugfs (en caso de que la misma zona térmica se elimine al mismo tiempo en dos subprocesos diferentes) y se restablezca a NULL. CC :6.8+  # 6.8+"
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/6c57bdd0505422d5ccd2df541d993aec978c842e",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/c7f7c37271787a7f77d7eedc132b0b419a76b4c8",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}