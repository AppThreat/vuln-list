{
  "id": "CVE-2024-26756",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-04-03T17:15:52.150",
  "lastModified": "2024-04-03T17:24:18.150",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nmd: Don't register sync_thread for reshape directly\n\nCurrently, if reshape is interrupted, then reassemble the array will\nregister sync_thread directly from pers-\u003erun(), in this case\n'MD_RECOVERY_RUNNING' is set directly, however, there is no guarantee\nthat md_do_sync() will be executed, hence stop_sync_thread() will hang\nbecause 'MD_RECOVERY_RUNNING' can't be cleared.\n\nLast patch make sure that md_do_sync() will set MD_RECOVERY_DONE,\nhowever, following hang can still be triggered by dm-raid test\nshell/lvconvert-raid-reshape.sh occasionally:\n\n[root@fedora ~]# cat /proc/1982/stack\n[\u003c0\u003e] stop_sync_thread+0x1ab/0x270 [md_mod]\n[\u003c0\u003e] md_frozen_sync_thread+0x5c/0xa0 [md_mod]\n[\u003c0\u003e] raid_presuspend+0x1e/0x70 [dm_raid]\n[\u003c0\u003e] dm_table_presuspend_targets+0x40/0xb0 [dm_mod]\n[\u003c0\u003e] __dm_destroy+0x2a5/0x310 [dm_mod]\n[\u003c0\u003e] dm_destroy+0x16/0x30 [dm_mod]\n[\u003c0\u003e] dev_remove+0x165/0x290 [dm_mod]\n[\u003c0\u003e] ctl_ioctl+0x4bb/0x7b0 [dm_mod]\n[\u003c0\u003e] dm_ctl_ioctl+0x11/0x20 [dm_mod]\n[\u003c0\u003e] vfs_ioctl+0x21/0x60\n[\u003c0\u003e] __x64_sys_ioctl+0xb9/0xe0\n[\u003c0\u003e] do_syscall_64+0xc6/0x230\n[\u003c0\u003e] entry_SYSCALL_64_after_hwframe+0x6c/0x74\n\nMeanwhile mddev-\u003erecovery is:\nMD_RECOVERY_RUNNING |\nMD_RECOVERY_INTR |\nMD_RECOVERY_RESHAPE |\nMD_RECOVERY_FROZEN\n\nFix this problem by remove the code to register sync_thread directly\nfrom raid10 and raid5. And let md_check_recovery() to register\nsync_thread."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: md: No registre sync_thread para remodelar directamente Actualmente, si se interrumpe el proceso de remodelación, volver a ensamblar la matriz registrará sync_thread directamente desde pers-\u0026gt;run(), en este caso 'MD_RECOVERY_RUNNING ' se configura directamente, sin embargo, no hay garantía de que md_do_sync() se ejecute, por lo tanto, stop_sync_thread() se bloqueará porque 'MD_RECOVERY_RUNNING' no se puede borrar. En el último parche, asegúrese de que md_do_sync() establezca MD_RECOVERY_DONE; sin embargo, dm-raid test shell/lvconvert-raid-reshape.sh ocasionalmente puede activar el siguiente bloqueo: [root@fedora ~]# cat /proc/1982/stack [\u0026lt;0\u0026gt;] stop_sync_thread+0x1ab/0x270 [md_mod] [\u0026lt;0\u0026gt;] md_frozen_sync_thread+0x5c/0xa0 [md_mod] [\u0026lt;0\u0026gt;] raid_presuspend+0x1e/0x70 [dm_raid] [\u0026lt;0\u0026gt;] dm_table_presuspend_targets+0x40/0xb0 [ dm_mod] [\u0026lt;0\u0026gt;] __dm_destroy+0x2a5/0x310 [dm_mod] [\u0026lt;0\u0026gt;] dm_destroy+0x16/0x30 [dm_mod] [\u0026lt;0\u0026gt;] dev_remove+0x165/0x290 [dm_mod] [\u0026lt;0\u0026gt;] ctl_ioctl+0x4bb/ 0x7b0 [dm_mod] [\u0026lt;0\u0026gt;] dm_ctl_ioctl+0x11/0x20 [dm_mod] [\u0026lt;0\u0026gt;] vfs_ioctl+0x21/0x60 [\u0026lt;0\u0026gt;] __x64_sys_ioctl+0xb9/0xe0 [\u0026lt;0\u0026gt;] do_syscall_64+0xc6/0x230 [\u0026lt;0 \u0026gt;] Entry_SYSCALL_64_after_hwframe+0x6c/0x74 Mientras tanto mddev-\u0026gt;recovery es: MD_RECOVERY_RUNNING | MD_RECOVERY_INTR | MD_RECOVERY_RESHAPE | MD_RECOVERY_FROZEN Solucione este problema eliminando el código para registrar sync_thread directamente desde raid10 y raid5. Y deje que md_check_recovery() registre sync_thread."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/13b520fb62b772e408f9b79c5fe18ad414e90417",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/ad39c08186f8a0f221337985036ba86731d6aafe",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}