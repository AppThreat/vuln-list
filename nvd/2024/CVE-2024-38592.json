{
  "id": "CVE-2024-38592",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-06-19T14:15:19.297",
  "lastModified": "2024-06-20T12:44:01.637",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/mediatek: Init `ddp_comp` with devm_kcalloc()\n\nIn the case where `conn_routes` is true we allocate an extra slot in\nthe `ddp_comp` array but mtk_drm_crtc_create() never seemed to\ninitialize it in the test case I ran. For me, this caused a later\ncrash when we looped through the array in mtk_drm_crtc_mode_valid().\nThis showed up for me when I booted with `slub_debug=FZPUA` which\npoisons the memory initially. Without `slub_debug` I couldn't\nreproduce, presumably because the later code handles the value being\nNULL and in most cases (not guaranteed in all cases) the memory the\nallocator returned started out as 0.\n\nIt really doesn't hurt to initialize the array with devm_kcalloc()\nsince the array is small and the overhead of initting a handful of\nelements to 0 is small. In general initting memory to zero is a safer\npractice and usually it's suggested to only use the non-initting alloc\nfunctions if you really need to.\n\nLet's switch the function to use an allocation function that zeros the\nmemory. For me, this avoids the crash."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm/mediatek: Init `ddp_comp` con devm_kcalloc() En el caso de que `conn_routes` sea verdadero, asignamos una ranura adicional en la matriz `ddp_comp` pero mtk_drm_crtc_create() nunca apareció para inicializarlo en el caso de prueba que ejecuté. Para mí, esto provocó un bloqueo posterior cuando recorrimos la matriz en mtk_drm_crtc_mode_valid(). Esto me apareció cuando arranqué con `slub_debug=FZPUA` que envenena la memoria inicialmente. Sin `slub_debug` no pude reproducir, presumiblemente porque el código posterior maneja que el valor sea NULL y en la mayoría de los casos (no garantizado en todos los casos) la memoria que devolvió el asignador comenzó como 0. Realmente no está de más inicializar el array con devm_kcalloc() ya que la matriz es pequeña y la sobrecarga de iniciar un puñado de elementos en 0 es pequeña. En general, iniciar la memoria a cero es una práctica más segura y, por lo general, se sugiere usar solo las funciones de asignación que no son de inicio si realmente es necesario. Cambiemos la función para usar una función de asignación que ponga a cero la memoria. Para mí, esto evita el accidente."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/01a2c5123e27b3c4685bf2fc4c2e879f6e0c7b33",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/9fe2cc3fa44f7ad7ba5f29c1a68b2b924c17b9b1",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/cf69d0af7db917b82aceaa44b7b1b9376609da22",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}