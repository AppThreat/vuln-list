{
  "id": "CVE-2024-36894",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-05-30T16:15:12.857",
  "lastModified": "2024-06-21T14:15:12.163",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: gadget: f_fs: Fix race between aio_cancel() and AIO request complete\n\nFFS based applications can utilize the aio_cancel() callback to dequeue\npending USB requests submitted to the UDC.  There is a scenario where the\nFFS application issues an AIO cancel call, while the UDC is handling a\nsoft disconnect.  For a DWC3 based implementation, the callstack looks\nlike the following:\n\n    DWC3 Gadget                               FFS Application\ndwc3_gadget_soft_disconnect()              ...\n  --\u003e dwc3_stop_active_transfers()\n    --\u003e dwc3_gadget_giveback(-ESHUTDOWN)\n      --\u003e ffs_epfile_async_io_complete()   ffs_aio_cancel()\n        --\u003e usb_ep_free_request()            --\u003e usb_ep_dequeue()\n\nThere is currently no locking implemented between the AIO completion\nhandler and AIO cancel, so the issue occurs if the completion routine is\nrunning in parallel to an AIO cancel call coming from the FFS application.\nAs the completion call frees the USB request (io_data-\u003ereq) the FFS\napplication is also referencing it for the usb_ep_dequeue() call.  This can\nlead to accessing a stale/hanging pointer.\n\ncommit b566d38857fc (\"usb: gadget: f_fs: use io_data-\u003estatus consistently\")\nrelocated the usb_ep_free_request() into ffs_epfile_async_io_complete().\nHowever, in order to properly implement locking to mitigate this issue, the\nspinlock can't be added to ffs_epfile_async_io_complete(), as\nusb_ep_dequeue() (if successfully dequeuing a USB request) will call the\nfunction driver's completion handler in the same context.  Hence, leading\ninto a deadlock.\n\nFix this issue by moving the usb_ep_free_request() back to\nffs_user_copy_worker(), and ensuring that it explicitly sets io_data-\u003ereq\nto NULL after freeing it within the ffs-\u003eeps_lock.  This resolves the race\ncondition above, as the ffs_aio_cancel() routine will not continue\nattempting to dequeue a request that has already been freed, or the\nffs_user_copy_work() not freeing the USB request until the AIO cancel is\ndone referencing it.\n\nThis fix depends on\n  commit b566d38857fc (\"usb: gadget: f_fs: use io_data-\u003estatus\n  consistently\")"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: usb: gadget: f_fs: corrige la ejecución entre aio_cancel() y la solicitud AIO. Las aplicaciones basadas en FFS completas pueden utilizar la devolución de llamada aio_cancel() para quitar de la cola las solicitudes USB pendientes enviadas al UDC. Existe un escenario en el que la aplicación FFS emite una llamada de cancelación de AIO, mientras el UDC maneja una desconexión suave. Para una implementación basada en DWC3, la pila de llamadas se parece a la siguiente: Aplicación DWC3 Gadget FFS dwc3_gadget_soft_disconnect() ... --\u0026gt; dwc3_stop_active_transfers() --\u0026gt; dwc3_gadget_giveback(-ESHUTDOWN) --\u0026gt; ffs_epfile_async_io_complete() ffs_aio_cancel() --\u0026gt; usb_ep_free_request () --\u0026gt; usb_ep_dequeue() Actualmente no hay ningún bloqueo implementado entre el controlador de finalización de AIO y la cancelación de AIO, por lo que el problema ocurre si la rutina de finalización se ejecuta en paralelo a una llamada de cancelación de AIO proveniente de la aplicación FFS. A medida que la llamada de finalización libera la solicitud USB (io_data-\u0026gt;req), la aplicación FFS también hace referencia a ella para la llamada usb_ep_dequeue(). Esto puede llevar a acceder a un puntero obsoleto/colgado. commit b566d38857fc (\"usb: gadget: f_fs: use io_data-\u0026gt;status consistentemente\") reubicó usb_ep_free_request() en ffs_epfile_async_io_complete(). Sin embargo, para implementar correctamente el bloqueo para mitigar este problema, el spinlock no se puede agregar a ffs_epfile_async_io_complete(), ya que usb_ep_dequeue() (si se elimina con éxito una solicitud USB) llamará al controlador de finalización del controlador de función en el mismo contexto. De ahí que se llegue a un punto muerto. Solucione este problema moviendo usb_ep_free_request() de nuevo a ffs_user_copy_worker() y asegurándose de que establezca explícitamente io_data-\u0026gt;req en NULL después de liberarlo dentro de ffs-\u0026gt;eps_lock. Esto resuelve la condición de ejecución anterior, ya que la rutina ffs_aio_cancel() no continuará intentando sacar de la cola una solicitud que ya ha sido liberada, o ffs_user_copy_work() no liberará la solicitud USB hasta que la cancelación de AIO termine de hacer referencia a ella. Esta solución depende de el commit b566d38857fc (\"usb: gadget: f_fs: use io_data-\u0026gt;status consistentemente\")"
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/24729b307eefcd7c476065cd7351c1a018082c19",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/73c05ad46bb4fbbdb346004651576d1c8dbcffbb",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/a0fdccb1c9e027e3195f947f61aa87d6d0d2ea14",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/d7461830823242702f5d84084bcccb25159003f4",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}